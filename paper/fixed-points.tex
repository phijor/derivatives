\section{Derivatives of Fixed Points}\label{fixed-points}

Containers let us model inductive data types as fixed points to substitution \( \Subst{\Blank}{\Blank} \):
if \( F \) describes the branching of an inductive data type, then there is a corresponding
container \( \mu F \) such that \( \CartIso{\Subst{F}{\mu F}}{\mu F} \).
This lets us turn informal recursive specifications such as \( \Op{List}(X) = 1 + X \times \Op{List}(X) \)
into a precise description of \( \Op{List} \) as a container.
\Citeauthor{AbbottEtAl2005DataDifferentiating} prove that the derivative of a fixed-point container
is itself a fixed point: \( \Der{(\mu F)} \) is equivalent to \( \mu F' \) for some \( F' \) derived from \( F \).
To do so, they recognize that each \( \mu F \) essentially behaves like repeated substitution \( \Subst{F}{\Subst{F}{\Subst{F}{\ldots}}} \),
and infer a fixed-point rule from the chain rule.

Our goal is to derive a similar fixed-point rule for our generalized derivative,
ideally by deriving it from the chain-rule as well.
This begs the question: if in general the chain-rule rule is lax,
is it ever possible to have a strong fixed-point rule?
It appears that the answer to this question is \enquote{it depends}:
we are able to show (cf.~\autoref{strong-mu-rule-iff-strong-chain-rule})
that the fixed-point rule for an \( (I + 1) \)-indexed container \( F \) is strong if and only if the chain rule
between \( F \) and \( \mu F \) is.

\subsection{Indexed Containers}

To define and reason about an operation \( \mu \) taking a container to a fixed-point,
we first have to recall the definition of indexed containers.
These encode data types polymorphic in more than one variable:
\begin{definition}[note={Indexed containers}]
  Let \( I : \Type \). The type of \emph{\( I \)-ary} or \emph{\( I \)-indexed containers} is
  \(
    \Cont_{I} \DefEq \sum_{S : \Type} (I \to S \to \Type)
  \).
\end{definition}
Ordinary containers correspond to unary containers, \( \Cont_{1} \).
Each index \( i : I \) corresponds to a variable in the type that a container describes.
In particular, \( (I + 1) \)-indexed containers are used to transcribe fixed-point expressions that contain an extra recursion variable.
We call \( (I + 1) \)-indexed containers \emph{signature containers}; their fixed points describe inductive types.
\begin{example}
  \newcommand*{\Nil}{\Op{nil}}
  \newcommand*{\Cons}{\Op{cons}}
  In the informal specification \( \Op{List}(X) = \mu Y.\, 1 + X \times Y \),
  the expression \( L(X, Y) = 1 + X \times Y \) is transcribed into a binary container \( L \), indexed by the type \( 2 \).
  Its positions at index \( \Op{y} \DefEq \Inr(\bullet) : 2 \) encode occurrences of the recursion variable \( Y \),
  those at \( \Op{x} \DefEq \Inl(\bullet) : 2 \) occurrences of \( X \).
  It has two shapes, \( \Nil \) and \( \Cons \),
  over which there are positions
  \begin{align*}
    L_{\Ps}(\Nil, \Op{x}) &\DefEq 0 & L_{\Ps}(\Cons, \Op{x}) &\DefEq 1 \\
    L_{\Ps}(\Nil, \Op{y}) &\DefEq 0 & L_{\Ps}(\Cons, \Op{y}) &\DefEq 1 \qedhere
  \end{align*}
\end{example}

Cartesian morphisms between containers \(F , G : \Cont_{I} \) are defined by ranging over all indices \( I \):
\[
  \Cart{F}{G} \DefEq \smashoperator[l]{\sum_{f : F_{\Sh} \to G_{\Sh}}} \prod_{i : I, s : F_{\Sh}} G_{\Ps}(i, f(s)) \simeq F_{\Ps}(i, s)
\]
Together, \( I \)-indexed containers again assemble into a wild category, \( \ContCart_{I} \).
We denote by \( \IContCart{I}_{n,k} \) the wild subcategories of \( I \)-indexed, \( (n, k) \)-truncated containers.
Each container in \( I \) variables is also one in \( I + 1 \) variables:
For \( F : \Cont_I \), denote by \( \Wk{F} : \Cont_{I+1} \) the inclusion given by
\[
  \Wk{F}_{\Ps}(\Just{i}) \DefEq F_{\Ps}(i), \quad \Wk{F}_{\Ps}(\Nothing) \DefEq 0
\]
To aid readability, we denote an \( I+1 \)-indexed container \( (\MkCont{S}{\bar{P}}) \) by \( (\MkCont{S}{\vec{P}, P}) \),
where \( \vec{P}_i \DefEq \bar{P}_{\Just(i)} \) and \( P \DefEq \bar{P}_{\Nothing} \).
In particular, \( \Wk{(\MkCont{S}{P})} = (\MkCont{S}{P,0}) \).
For \( i : I \), the \( i \)th projection container is \( \pi_i \DefEq (\MkCont{1}{\lambda j\,\Blank.\,{i = j}}) : \Cont_I \).
If \( i \) is isolated, then \( i = j \) is a decidable proposition for any \( j : I \);
in this case \( \pi_i \) is equivalent to a container whose \( i \)th type of positions is \( 1 \),
and \( 0 \) for any other direction.
As expected, indexed containers are closed under constants \( \CConst(A) \), sums \( (\CPlus) \) and products \( (\CTimes) \).
Substitution generalizes to an operation that places a container inside the positions at index \( \Nothing : I + 1 \) of an \( (I + 1) \)-indexed container:
\begin{definition}
    Substitution is an operation \( \Subst{\Blank}{\Blank} : \Cont_{I+1} \to \Cont_{I} \to \Cont_{I} \),
    defined as follows:
    \begin{align*}
      \Subst{(\MkCont{S}{\vec{P}, P})}{(\MkCont{T}{Q})}_{\Sh} &\DefEq \sum_{s : S} P(s) \to T
        \\
      \Subst{(\MkCont{S}{\vec{P}, P})}{(\MkCont{T}{Q})}_{\Ps} &\DefEq \lambda (s, f).\, \vec{P}_i(s) + \smashoperator{\sum_{p : P(s)}} Q_i(fp)
        \qedhere
    \end{align*}
\end{definition}
Similarly, we can lift derivatives to indexed containers.
For an \( I \)-indexed container, we can take a derivative with respect to any index \( i : I \), as long as equality with \( i \) is decidable:
\begin{definition}[note={Derivative of \( I \)-ary containers}]
  Let \( F \JudgeEq (\MkCont{S}{P}) : \Cont_I \) and \( i : \Isolated{I} \).
  The \( i \)th derivative \( {\Der_i}F \DefEq (\MkCont{S'}{P'}) : \Cont_I \) is defined as follows:
  \begin{align*}
    S' &\DefEq \sum_{s : S} \Isolated{P_i(s)} \\
    P'(j, s, p) &\DefEq
      \begin{cases}
        P_i(s) \setminus p & \text{if } i = j \\
        P_j(s) & \text{otherwise}
      \end{cases}
      \qedhere
  \end{align*}
\end{definition}

In order to reduce visual clutter, we investigate only fixed-points of \emph{binary} containers, indexed by \( 2 = 1 + 1 \).
However, our arguments apply to \( (I + 1) \)-indexed containers in general.
In particular, we write \( \Der_0 \) and \( \Der_1 \) for the two possible derivatives of a binary container,
that is \( \Der_{\Inl(\bullet)} \) and \( \Der_{\Inr(\bullet)} \).
In the unary case, we omit the subscript and simply write \( \Der \) for \( \Der_{\bullet} \).

Derivatives of indexed containers satisfy the same basic laws for constants, sums and products as in the unary case.
Derivatives of composites follow a lax chain rule, which now accounts for multiple indices.
As promised in the discussion of \autoref{lax-chain-rule},
its construction factors into smaller steps that make it obvious why, in general, it is not invertible:
\begin{problem}[note={Lax chain rule for binary containers}]\label{binary-chain-rule}
  Let \( F : \Cont_2 \) and \( G : \Cont_1 \).
  Define a cartesian morphism
  \[
    \Chain_{F,G}
      :
    \Cart%
      {{\Der_0{F}}[G] \CPlus \big( {\Der_1{F}}[G] \CTimes \Der{G} \big)}%
      {\Der{(F[G])}}
  \]
  \begin{construction}
    \renewcommand*{\L}{\Op{L}}
    \newcommand*{\R}{\Op{R}}
    Let \( F \JudgeEq (\MkCont{S}{P}) \), \( G \JudgeEq (\MkCont{T}{Q}) \).
    We define auxiliary containers \( H_1, H_2 \) and factor the morphism through a pair of equivalences as follows:
    \[
      \begin{tikzcd}[column sep=large]
        {\mathllap{\L \DefEq {}} {{\Der_0{F}}[G] \CPlus \big( {\Der_1{F}}[G] \CTimes \Der{G} \big)}}
          \ar[d, multimap-multimap]
          \ar[r, -multimap, dashed, "\Chain_{F,G}"]
          &
        {\Der{(F[G])} \mathrlap{{} \eqcolon \R}}
          \ar[d, multimap-multimap]
          \\
        H_1
          \ar[r, -multimap, "\eta"{swap}]
          &
        H_2
      \end{tikzcd}
    \]
    Following the argument in \autoref{lax-chain-rule} and some type yoga,
    we see that the type of shapes of \( \L \) is equivalent to
    \begin{align}
      U_1 \DefEq
        \sum_{s : S} \sum_{f : P_1(s) \to T} \Isolated{P_0(s)} + \smashoperator{\sum_{p : \Isolated{P_1(s)}}} \Isolated{Q(fp)}
          \label{binary-chain-rule-shape-equiv}
    \end{align}
    Denote this equivalence by \( f_1 : {\L}_{\Sh} \simeq U_1 \), and define \( H_1 \DefEq (\MkCont{U_1}{{\L}_{\Ps} \circ f_1^{\Inv}}) \).
    This defines the equivalence \( \CartIso{\L}{H_1} \) to the left.

    On the other side we obtain an equivalence \( f_2 : U_2 \simeq {\R}_{\Sh} \)
    by distributing \( \Isolated{(\Blank)} \) over binary sums:
    \begin{align*}
      U_2
      &\DefEq
      \sum_{s : S} \sum_{f : P_1(s) \to T}
        \Isolated{P_0(s)} + \Isolated{\big( \smashoperator{\sum_{p : P_1(s)}} Q(fp) \big)}
        \\
      &\simeq
      \sum_{s : S} \sum_{f : P_1(s) \to T}
        \Isolated{\big( P_0(s) + \smashoperator{\sum_{p : {P_1(s)}}} Q(fp) \big)}
        \\
      &\simeq
        {\R}_{\Sh}
    \end{align*}
    Let \( H_2 \DefEq (\MkCont{U_2}{{\R}_{\Ps} \circ f_2}) \),
    which yields the equivalence \( \CartIso{H_2}{\R} \) to the right.

    Let us now define \( \eta : H_1 \multimap H_2 \).
    As in \autoref{lax-chain-rule}, define the shape map \( \eta_{\Sh} : U_1 \to U_2 \) using \( \SigmaIsolate_{P_1(s),Q(f(\Blank))} \).
    On positions, the equivalence
    \(
      \eta_{\Ps}(u) : H_2^{\Ps}(\eta_{\Sh}(u)) \simeq H_1^{\Ps}(u)
    \)
    is defined by cases, depending on which side of the sum \( u : U_1 \) falls.
    Let \( s : S \), \( f : P_1(s) \to T \).
    In case of \( u \JudgeEq (s, f, \Inl{p_0}) \) for \( p_0 : \Isolated{P_0(s)} \), our goal is to give
    \[
      ( \Isolated{P_0(s)} + B ) \setminus \Inl(p_0)
        \simeq
      ( \Isolated{P_0(s)} \setminus p_0 ) + B
    \]
    for \( B \DefEq {\textstyle \sum_{p : P_1(s)} Q(fp) } \), which is an instance of \autoref{sum-remove-equiv}.

    When \( u \JudgeEq (s, f, \Inr(p_1, q)) \) for some \( p_1 : \Isolated{P_1(s)} \) and \( q : \Isolated{Q(fp)} \),
    we rewrite the type of positions as follows:
    \begin{align}
      H_2^{\Ps}(\eta_{\Sh}(s , f , \Inr(p_1, q)))
        &\mathrel{\JudgeEq}
          \big( P_0(s) + \smashoperator{\sum_{p : P_1(s)}} Q(f p) \big) \setminus \Inr(p_1, q)
          \notag
          \\
        &\simeq
          P_0(s) + \big( \smashoperator{\sum_{p : P_1(s)}} Q(f p) \big) \setminus (p_1, q)
          \label{binary-chain-rule-pos-equiv-sum-minus}
          \\
        &\simeq
          P_0(s) + \smashoperator{\sum_{p : P_1(s) \setminus p}} Q(f p) + (Q(f\,p_1) \setminus q)
          \label{binary-chain-rule-pos-equiv-sigma-minus}
          \\
        &\mathrel{\JudgeEq}
          H_1^{\Ps}(s, f, \Inr{(p_1, q)})
          \notag
    \end{align}
    In \eqref{binary-chain-rule-pos-equiv-sum-minus}, we move the pair \( (p_1, q) \) to the right of the sum (\autoref{sum-remove-equiv}).
    For \eqref{binary-chain-rule-pos-equiv-sigma-minus},
    we split the \( \Sigma \)-type by applying \autoref{is-equiv-sigma-remove}.
    This is justified since both \( p_1 \) and \( q \) are isolated points,
    and together, the pair \( (p_1, q) \) is isolated in \( \sum_{p : P_1(s)} Q(f p) \) by \autoref{is-isolated-pair}.
  \end{construction}
\end{problem}

This factorization makes it obvious that the binary chain rule is again an embedding of containers,
and strong whenever isolated points distribute over dependent sums:
\begin{proposition}\label{is-embedding-binary-chain-rule}
  For \( F : \Cont_2 \) and \( G : \Cont_1 \), \( \Chain_{F,G} \) is an embedding. \qed
\end{proposition}
\begin{proposition}\label{strong-binary-chain-rule-iff-is-equiv-sigma-isolate}
  For all \( F \JudgeEq (\MkCont{S}{P}) : \Cont_2 \) and \( G \JudgeEq (\MkCont{T}{Q}) : \Cont_1 \), the following are equivalent:
  \begin{enumerate}
    \item \( \Chain_{F,G} \) is an equivalence of unary containers.
    \item For all \( s : S \) and \( f : P_1(s) \to T \), \( \SigmaIsolate_{P_1(s), Q(f(\Blank))} \) is an equivalence.
  \end{enumerate}
  \begin{proof}
    The morphism \( \Chain_{F,G} \) is an equivalence if and only if \( \eta_{\Sh} \) in the above construction is an equivalence of types.
    This in turn is exactly the case when the second condition holds.
  \end{proof}
\end{proposition}

Like in \autoref{discrete-strong-chain-rule}, this is the case for discrete containers:
\begin{proposition}\label{discrete-strong-binary-chain-rule}
  If \( F : \Cont_2 \) and \( G : \Cont_1 \) are discrete, then \( \Chain_{F,G} \) is an equivalence. \qed
\end{proposition}

\subsection{Fixed Points of Containers}\label{fixed-point-containers}

To show how derivatives of untruncated containers interact with fixed points,
we first have to give a suitable specification of what we mean by such a \enquote{fixed point}.
Traditionally, the (smallest) fixed point associated to a signature container is constructed as follow:
Given an \( I \)-indexed and set-truncated container \( (\MkCont{S}{P}) \),
it is interpreted as a functor \( \llbracket \MkCont{S}{P} \rrbracket : [\Set^I, \Set] \),
which takes families \( \vec{X} : I \to \Set \) to
\[
  \llbracket \MkCont{S}{P} \rrbracket \vec{X} \DefEq \sum_{s : S} \prod_{i : I} P_i(s) \to \vec{X}_i
\]
This defines a full and faithful embedding of the category \( \IContCart{I}_{0,0} \) into the category of functors \( [\Set^I, \Set] \)~\cite[Thm.~3.4]{AbbottEtAl2005ContainersConstructingstrictly}.
Notably, this embedding reflects much of the structure of the functor category \( [\Set^I, \Set] \) back into containers,
allowing concise proofs for a number of properties.
In particular, given a signature container \( F : \Cont_{I+1} \), its interpretation \( \llbracket F \rrbracket(\vec{X}, \Blank) : [ \Set, \Set ] \)
admits an initial algebra for any \( \vec{X} \).
This initial algebra can be shown to lie in the image of the interpretation functor, hence it defines a necessarily unique \( I \)-indexed container \( \mu F \),
which is regarded as the smallest fixed point of \( F \).

Recently,
\citeauthor{DamatoEtAl2025FormalisingInductiveCoinductive} have expanded upon this idea in~\cite{DamatoEtAl2025FormalisingInductiveCoinductive},
and taken untruncated \( I \)-indexed containers to wild functors typed \( [ \Type^I, \Type ] \).
They show that for any \( F : \Cont_{I + 1} \) and \( \vec{X} : I \to \Type \),
the wild functor \( \llbracket F \rrbracket(\vec{X}, \Blank) : [\Type, \Type] \) admits an initial algebra
whose carrier is given by \( \llbracket \mu F \rrbracket\vec{X} \) --- the interpretation of some container \( \mu F : \Cont_I \).
Ideally, one would like to show that this construction is natural in \( \vec{X} \) and
pull its properties back along \( \llbracket \Blank \rrbracket \),
thus proving that \( \mu F \) itself is defined universally among \emph{containers},
without needing to reference their interpretations.
This, however, is hampered by the fact that we cannot (yet) internally prove that the wild categories involved are suitably coherent,
that is \( (\infty,1) \)-categories in an appropriate sense.
If they were, one could attempt to show that \( \llbracket \Blank \rrbracket \) is a structure-preserving embedding:
a particularly elegant way to show that \( \llbracket \Blank \rrbracket \) is fully faithful for sets
is given by \citeauthor{Damato2023RevisitingContainersCubical} in \cite{Damato2023RevisitingContainersCubical} and relies almost exclusively on the Yoneda-lemma,
which should make the proof amenable to generalization.

In light of this, we are going to define a notion of fixed point entirely internal to the wild category of containers,
which does not reference the interpretation functor \( \Ext{\Blank} \) at all.
Barring the above-mentioned issues, this should correspond to the more traditional definition of container fixed points in terms of \( \Ext{\Blank} \).
First, note that substitution into a fixed container behaves functorially:
\begin{problem}
  Given \( F : \Cont_{I+1} \), extend \( \Subst{F}{\Blank} \) to a wild endofunctor on \( \ContCart_I \).
\end{problem}
\begin{construction}
  Straightforward.
\end{construction}
It also commutes with composition under the interpretation of containers:
for all \( F : \Cont_{I + 1} \) and \( G : \Cont_I \),
there is an equivalence of types
\( \llbracket \Subst{F}{G} \rrbracket \vec{X} \simeq \llbracket F \rrbracket(\vec{X}, \llbracket G \rrbracket\vec{X}) \), natural in \( \vec{X} : I \to \Type \).
In particular, a fixed point of containers \( \varphi : \CartIso{\Subst{F}{G}}{G} \) induces a fixed point of \( \Ext{F}(\vec{X}, \Blank ) \),
which is exactly a container fixed point in the sense of \cite{DamatoEtAl2025FormalisingInductiveCoinductive}.

We thus define smallest fixed points of a signature container \( F \) without reference to its associated functor \( \Ext{F} \),
namely as initial algebras of the wild functor \( \Subst{F}{\Blank} \).
Let us set this up precisely:
\begin{problem}[note={\( \Subst{F}{\Blank} \)-algebras}]
  Given \( F : \Cont_{I+1} \), define the structure of a wild category \( \Alg{\Subst{F}{\Blank}} \),
  such that
  \begin{itemize}
    \item objects are of type \( \sum_{G : \Cont_I} \Cart{\Subst{F}{G}}{G} \),
    \item morphisms \( \Alg{\Subst{F}{\Blank}}((G, g), (H, h)) \) are container morphisms
      \( f : \Cart{G}{G'} \) together with a path \( f_\sharp : f \circ h = g \circ \Subst{F}{f} \) ensuring that the square
      \[
        \begin{tikzcd}
          \Subst{F}{G} \ar[r, -multimap, "\Subst{F}{f}", ""{swap,name=Ff}] & \Subst{F}{H} \\
          G \ar[r, -multimap, "f"{swap}, ""{name=f}] & H
          \ar[from=1-1, to=2-1, -multimap, "h"{swap}]
          \ar[from=1-2, to=2-2, -multimap, "g"]
          \ar[from=Ff, to=f, phantom, "{\scriptstyle f_\sharp}"]
        \end{tikzcd}
      \]
      commutes.
  \end{itemize}
\end{problem}
\begin{construction}
  Identities and composite morphisms are defines as expected.
  However, unlike in 1-categories, unitality and associativity of composition is not automatically inherited from the base category \( \Cont_I \),
  since we have to ensure that there are higher paths between composite squares, such as
  \[
    \begin{tikzcd}
      \Subst{F}{G} \ar[r, -multimap, "\Subst{F}{f}", ""{swap,name=Ff}]
        & \Subst{F}{H} \ar[r, -multimap, "\Subst{F}{\id}", ""{swap,name=Fid}]
        & \Subst{F}{H}  \\
      G \ar[r, -multimap, "f"{swap}, ""{name=f}]
        & H \ar[r, -multimap, "\id"{swap}, ""{name=id}]
        & H
      \ar[from=1-1, to=2-1, -multimap, "h"{swap}]
      \ar[from=1-2, to=2-2, -multimap, "g"]
      \ar[from=1-3, to=2-3, -multimap, "g"]
      \ar[from=Ff, to=f, phantom, "{\scriptstyle f_\sharp}"]
      \ar[from=Fid, to=id, phantom, "{\scriptstyle \id_\sharp}"]
    \end{tikzcd}
    =
    \begin{tikzcd}
      \Subst{F}{G} \ar[r, -multimap, "\Subst{F}{f}", ""{swap,name=Ff}] & \Subst{F}{H} \\
      G \ar[r, -multimap, "f"{swap}, ""{name=f}] & H
      \ar[from=1-1, to=2-1, -multimap, "h"{swap}]
      \ar[from=1-2, to=2-2, -multimap, "g"]
      \ar[from=Ff, to=f, phantom, "{\scriptstyle f_\sharp}"]
    \end{tikzcd}
  \]
  Fortunately, these higher paths are straightforward to construct by extensionality of container morphisms.
\end{construction}

Unlike other concepts, we can express initiality in wild categories coherently as a \emph{property} of an object:
an object \( 0 \) of a wild category \( \mathcal{C} \) is \emph{initial}
if for any other object \( X \), the type of morphisms \( \mathcal{C}(0, X) \) is \emph{contractible}.
Hence we say:
\begin{definition}
  A smallest fixed point of a signature container \( F : \Cont_{I + 1} \) is an initial \( \Subst{F}{\Blank} \)-algebra.
\end{definition}
Spelled out, a smallest \( F \)-fixed point it consists of a \emph{carrier} \( M : \Cont_I \)
and a structure map \( m : \Cart{\Subst{F}{M}}{M} \)
such that for any other algebra \( (G, g) \), the type of morphisms \( \Alg{\Subst{F}{\Blank}}((M, m), (G, g)) \) is contractible.
The latter means exactly that there is a unique map \( r : \Cart{M}{G} \) that commutes with the structure maps \( m \) and \( g \).
As a consequence, the carriers of smallest fixed points are equivalent (hence equal) as containers.

We now show, assuming access to \( \W \)-types, that all containers admit smallest fixed points in this sense:
Recall that for \( A : \Type \) and \( B : A \to \Type \),
the type \( \W(A, B) \) has the single constructor
\begin{equation*}
  {
    \AxiomC{\( a : A \)}
    \AxiomC{\( f : B(a) \to \W(A, B) \)}
    \BinaryInfC{\( \Sup(a, f) : \W(A, B) \)}
    \DisplayProof
  }
\end{equation*}
Each \( w : \W(A, B) \) is a well-founded tree with \( A \)-labeled nodes, and \( B(a) \)-branching subtrees.
A path to some node inside \( w \), labelled by \( C : A \to \Type \),
can be defined as an inductive family \( \bar{\W}_{A,B,C} : \W(A,B) \to \Type \) with two constructors, namely
\begin{center}
  \hspace*{\fill}
  {
    \AxiomC{\( c : C(a) \)}
    \UnaryInfC{\( \WTop(c) : \bar{\W}_{A, B, C}(\Sup(a, f)) \)}
    \DisplayProof
  }
  \hfill%
  and
  \hfill%
  {
    \AxiomC{\( b : B(a) \)}
    \AxiomC{\( w : \WPath_{A,B,C}(f(b)) \)}
    \BinaryInfC{\( \WBelow(b, w) : \bar{\W}_{A, B, C}(\Sup(a, f)) \)}
    \DisplayProof
  }
  \hspace*{\fill}
\end{center}
for all \( a : A \) and \( f : B(a) \to \W(A, B) \).
Both \( \W \) and \( \bar{\W} \) can be described by unfolding them by one level
---
the constructors define equivalences
\begin{align*}
  \WIn &: \sum_{a : A} (B(a) \to \W(A, B)) \simeq \W(A, B)
    \\
  \WPathIn_{a, f} &: C(a) + \smashoperator{\sum_{b : B(a)}} \bar{\W}_{A,B,C}(f(b)) \simeq \bar{\W}_{A,B,C}(\Sup(a, f))
\end{align*}
for all \( a : A \) and \( f : B(a) \to \W(A, B)\).

We use \( \W \) and \( \bar{\W} \) to define the shapes and position, respectively, of the smallest fixed-point container:
\begin{definition}
  Let \( F \JudgeEq (\MkCont{S}{\vec{P},P}) : \Cont_{I+1} \), define \( {\mu F} \DefEq (\MkCont{S^\mu}{P^\mu}) : \Cont_I \):
  \begin{align*}
    S^\mu &\DefEq \W(S, P) \\
    P^\mu_i & \DefEq \bar{\W}_{S,P,\vec{P}}
    \qedhere
  \end{align*}
\end{definition}

These let us derive a fixed-point to substitution:
\begin{problem}
  Define an equivalence of containers \( \In_F : F[{\mu F}] \CartEquiv {\mu F} \).
  \begin{construction}
    Let \( F \JudgeEq (\MkCont{S}{\vec{P},P}) \).
    Shapes of \( \Subst{F}{\mu F} \) are \( \sum_{s : S} (P(s) \to \W(S, P)) \),
    hence \( \WIn \) establishes an equivalence with the shapes of \( \mu F \).
    Similarly, the positions of \( \Subst{F}{\mu F} \) are equivalent to those of \( \mu F \) via \( \WPathIn \).
  \end{construction}
\end{problem}

Together, \( \mu F \) and \( \In_F \) form an \( \Subst{F}{\Blank} \)-algebra.
We define a non-dependent recursion principle for maps out of \( \mu F \),
which yields a morphism into \emph{any} other algebra:
\begin{problem}[note={\( \mu \)-recursion}]\label{mu-rec}
  Define a recursion principle for morphisms out of \( \mu \)-containers.
  That is, for any \( F : \Cont_{I+1} \), \( G : \Cont_I \) and \( \alpha : \Cart{F[G]}{G} \),
  give a morphism
  \[
      \Rec_{F}(\alpha) : \Cart{\mu F}{G}
  \]
  and a filler of
    \begin{equation}\label{mu-rec-comm}
      \begin{tikzcd}[column sep=huge]
        \Subst{F}{\mu F} & \Subst{F}{G} \\
        {\mu F}          & G
        \ar[from=1-1, to=1-2, -multimap, "\Subst{F}{\Rec_F(\alpha)}"]
        \ar[from=1-1, to=2-1, -multimap, "\In_F"{swap}]
        \ar[from=2-1, to=2-2, -multimap, "\Rec_F(\alpha)"{swap}]
        \ar[from=1-2, to=2-2, -multimap, "\alpha"]
      \end{tikzcd}
    \end{equation}
    for all \( \alpha : \Cart{\Subst{F}{G}}{G} \).
\end{problem}
\begin{construction}
  Let \( F \JudgeEq (\MkCont{S}{\vec{P},P}) \) and \( G \JudgeEq (\MkCont{T}{Q}) \).
  Abbreviate \( \Rec_{F}(\alpha) \) by \( \Rec \).
  On shapes, \( \Rec \)  is defined by \( \W \)-recursion,
  \begin{align*}
    \Rec_{\Sh} &: \W(S, P) \to T \\
    \Rec_{\Sh} &\DefEq \lambda(\Sup(s, f)).\, \alpha_{\Sh} (s, \Rec_{\Sh} \circ f)
  \end{align*}
  On positions, we define map
  \( {u : Q_i(\Rec_{\Sh}(w)) \to \bar{\W}_{S,P,\vec{P}}(w)} \) by induction on \( w : \W(S, P) \).
  For \( w \JudgeEq \Sup(s, f) \), it is the composite
  \[
    \begin{tikzcd}
      Q_i(\alpha_{\Sh}(s , \Rec_{\Sh} \circ f)
        \ar[r, dashed, "u"]
        \ar[d, "{\alpha_{\Ps}(i, \Rec_{\Sh} \circ f)}"{swap}]
        &
      \bar{\W}_{S,P,\vec{P}}(\Sup(s, f))
        \\
      \vec{P}_i(s) + \sum_{p \in P(s)} Q_i(\Rec_{\Sh}(f(p)))
        \ar[r, "u^*"{swap}]
        &
      \vec{P}_i(s) + \sum_{p \in P(s)} \bar{\W}_{S,P,\vec{P}}(\Sup(s, f))
        \ar[u, "\WPathIn"{swap}]
    \end{tikzcd}
  \]
  in which \( u^* \) applies \( u(f(p)) \) recursively in the second component of the \( \Sigma \)-type.
  By induction, all maps in this composite are equivalences, hence it is the map underlying
  the desired equivalence of positions, \( \Rec_{\Ps}(i, w) \).

  To show that \eqref{mu-rec-comm} commutes, it suffices to find a filler for
  \begin{equation}\label{mu-rec-out-filler}
    \begin{tikzcd}[column sep=huge]
      \Subst{F}{\mu F} & \Subst{F}{G} \\
      {\mu F}          & G
      \ar[from=1-1, to=1-2, -multimap, "\Subst{F}{\Rec_F(\alpha)}"]
      \ar[from=1-1, to=2-1, multimap-, "\Out_F"{swap}]
      \ar[from=2-1, to=2-2, -multimap, "\Rec_F(\alpha)"{swap}]
      \ar[from=1-2, to=2-2, -multimap, "\alpha"]
    \end{tikzcd}
  \end{equation}
  as \( \In_F \) is an equivalence with inverse \( \Out_F \).
  This is done by \( \W \)-induction on the shapes of \( \mu F \).
\end{construction}

In fact, this morphism is uniquely determined, hence we get a fixed point for any signature container:
\begin{theorem}
  For all \( F : \Cont_{I + 1}\), the pair \( (\mu F, \In_F) \) is an initial \( \Subst{F}{\Blank} \)-algebra,
  hence a smallest fixed-point of \( F \).
  \begin{proof}
    Let \( (G, \alpha) \) be a second \( \Subst{F}{\Blank} \)-algebra.
    By definition, \( \Rec_F(\alpha) : \Cart{\mu F}{G} \) is an algebra morphism.
    It suffices to show that \( \Rec_F(\alpha) \) together with the filler \eqref{mu-rec-out-filler} is unique.
    That is, for any other algebra morphism \( \alpha^* : \Cart{\mu F}{G} \),
    there is a path \( p : \Rec_F(\alpha) = \alpha^* \),
    and over this path, there is a path \( q \) connecting the commuting squares
    \[
      \begin{tikzcd}[column sep=huge]
        \Subst{F}{\mu F} & \Subst{F}{G} \\
        {\mu F}          & G
        \ar[from=1-1, to=1-2, -multimap, "\Subst{F}{\Rec_F(\alpha)}"]
        \ar[from=1-1, to=2-1, multimap-, "\Out_F"{swap}]
        \ar[from=2-1, to=2-2, -multimap, "\Rec_F(\alpha)"{swap}]
        \ar[from=1-2, to=2-2, -multimap, "\alpha"]
      \end{tikzcd}
      \qquad\text{and}\qquad
      \begin{tikzcd}[column sep=huge]
        \Subst{F}{\mu F} & \Subst{F}{G} \\
        {\mu F}          & G
        \ar[from=1-1, to=1-2, -multimap, "\Subst{F}{\alpha^*}"]
        \ar[from=1-1, to=2-1, multimap-, "\Out_F"{swap}]
        \ar[from=2-1, to=2-2, -multimap, "\alpha^*"{swap}]
        \ar[from=1-2, to=2-2, -multimap, "\alpha"]
      \end{tikzcd}
    \]
    Let us sketch the proof.
    By extensionality of morphisms (\autoref{container-morphism-ext}), the path \( p \) can be given as a \( {\mu F}_{\!\Sh} \)-indexed family of paths.
    But \( {\mu F}_{\!\Sh} \) is a \( \W \)-type,
    hence we define \( p \) by \( \W \)-induction as a composite of two paths, \( p_1 \) and \( p_2 \),
    using the path \( \alpha^*_{\sharp} \) which ensures that \( \alpha^* \) is a morphism of algebras.
    The composite of these two paths is unique up to a unique dependent path, and from this we build the filler connecting the two squares above.
    In our mechanized proof, this construction makes extensive use Cubical Agda's primitive support for dependent path types and cube filling operations.
    This allows us to leave \texttt{transport} hell, and instead settle in \texttt{PathP}  purgatory.
  \end{proof}
\end{theorem}

\subsection{The \texorpdfstring{\( \mu \)-}{Fixed Point }Rule}

Having convinced ourselves that fixed points do exist even for untruncated containers, we can now characterize their derivatives.
Let \( F : \Cont_2 \).
If we think of \( \mu F \) as an \( F \)-branching tree, then \( \Der{\mu F} \) represents a type of trees with a hole.
Such a hole must be either in the position of a leaf or occur recursively in a branch,
which are given by the positions \( P_0 \) and \( P_1 \).
Hence, the derivative of \( \mu F \) is again tree-shaped,
with branching given by \( \Der_0{F} \) and \( \Der_1{F} \):
If \( F \) is discrete, there is an equivalence
\(
  \CartIso { \mu F' }{ \Der(\mu F) }
\)
in which
\(
  F' \DefEq
    { \Wk{\Der_0{F}[ {\mu F} ]} }
      \CPlus
    (
      \Wk{\Der_1{F}[ {\mu F} ]}
        \CTimes
      \Proj{1}
    )
\).
Proving that this is the case even for untruncated containers is not entirely straightforward.
There is however hope to recover at least a morphism out of \( \mu F' \) into \( \Der{\mu F} \) by recursion:

\begin{problem}[note={Lax \( \mu \)-rule}]\label{mu-rule}
  For \( F : \Cont_2 \), define by recursion a cartesian morphism
  \[
    \MuRule_F : \Cart{ \mu F' }{ \Der(\mu F) }
  \]
  where
  \(
    F' \DefEq
      { \Wk{\Der_0{F}[ {\mu F} ]} }
        \CPlus
      (
        \Wk{\Der_1{F}[ {\mu F} ]}
          \CTimes
        \Proj{1}
      )
    : \Cont_2
  \).
\end{problem}
  \begin{construction}
    Our goal is to provide some
    \(
      \alpha : \Cart{ \Subst{F'}{\Der{\mu F}} }{ \Der{\mu F} }
    \).
    First note that \( F' \) is a container in two variables,
    and substitution into the second replaces \( \Proj{1} \), i.e.\@ there is an equivalence
    \[
      \gamma_{\Highlight{Y}} :
      F'[\Highlight{Y}]
        \mathrel{\CartEquiv}
      { \Der_0{F}[ {\mu F} ] } \CPlus ( {\Der_1{F}[ {\mu F} ]} \CTimes \Highlight{Y} )
    \]
    for any choice of \( \Highlight{Y} : \Cont_1 \).
    In particular, for \( \Highlight{Y} \JudgeEq \Der(\mu F) \),
    the codomain of \( \gamma_{\Der{\mu F}} \) is exactly the domain of the binary chain rule (cf.~\autoref{binary-chain-rule}).
    Hence, we define \( \alpha \) as the following composite:
    \begin{equation*}
      \begin{tikzcd}[column sep=large]
        {F'[\Highlight{\Der(\mu F)}]}
          &
        {\Der(\mu F)}
          \\
        {
          { \Der_0{F}[ {\mu F} ] }
            \CPlus
          (
            {\Der_1{F}[ {\mu F} ]}
              \CTimes
            \Highlight{\Der(\mu F)}
          )
        }
          &
        \Der(F[\mu F])
        \ar[from=1-1, to=2-1, multimap-multimap, "\gamma_{\Highlight{\Der(\mu F)}}"{swap}]
        \ar[from=2-1, to=2-2, -multimap, "\Chain_{F,{\mu\!F}}"{swap}]
        \ar[from=2-2, to=1-2, multimap-multimap, "\Der(\In_F)"{swap}]
        \ar[from=1-1, to=1-2, dashed, -multimap, "\alpha"]
      \end{tikzcd}
    \end{equation*}
    Lastly, let \( \MuRule_F \DefEq \Rec_{F'}(\alpha) : \Cart{ \mu F' }{ \Der{(\mu F)} } \).
  \end{construction}

One advantage of defining the \( \mu \)-rule by recursion is that it highlights the dependency on the chain-rule.
First, observe that recursion reflects equivalence, in the following sense:
\begin{lemma}\label{is-equiv-from-mu-rec}
  Let \( \alpha : \Cart{\Subst{F}{G}}{G} \).
  If \( \Rec_{F}(\alpha) \) is an equivalence, then so is \( \alpha \).
  \begin{proof}
    Substitution \( \Subst{F}{-} \) preserves equivalences,
    so by 3-for-2 for equivalences of containers, \( \alpha \) on the right is an equivalence:
    \[
      \begin{tikzcd}[column sep=huge]
        \Subst{F}{\mu F} & \Subst{F}{G} \\
        {\mu F}          & G
        \ar[from=1-1, to=1-2, multimap-multimap, "\Subst{F}{\Rec_F(\alpha)}"]
        \ar[from=1-1, to=2-1, multimap-multimap, "\In_F"{swap}]
        \ar[from=2-1, to=2-2, multimap-multimap, "\Rec_F(\alpha)"{swap}]
        \ar[from=1-2, to=2-2, -multimap, "\alpha"]
      \end{tikzcd}
      \qedhere
    \]
  \end{proof}
\end{lemma}

Thus, a strong \( \mu \)-rule for some container necessarily implies a strong chain rule between \( F \) and \( \mu F \):
\begin{proposition}\label{strong-chain-rule-from-strong-mu-rule}
  Let \( F : \Cont_{I + 1} \).
  If \( \MuRule_F \) is an equivalence, then so is \( \Chain_{F,{\mu F}} \).
  \begin{proof}
    Assume that \( \MuRule_F \) is an equivalence.
    In \autoref{mu-rule}, \( \MuRule_F \) is defined by recursion from some \( \alpha \),
    hence \( \alpha \) is an equivalence by \autoref{is-equiv-from-mu-rec}.
    But \( \alpha \) is just \( \Chain_{F, {\mu F}} \) wedged between equivalences,
    so the latter is an equivalence.
  \end{proof}
\end{proposition}

We would like to establish the converse to this as well, but cannot do so directly,
as the converse of \autoref{is-equiv-from-mu-rec} does not hold:
in general, there are fixed points \( \varphi : \Cart{ \Subst{F}{G} }{ G } \) such that \( \mu F \) and \( G \) are not equivalent as containers.
However, \( \mu F \) is the smallest among such fixed points, and embeds into any other (pre-)fixed point:
\begin{lemma}\label{is-embedding-mu-rec}
  If \( \alpha : \Cart{\Subst{F}{G}}{G} \) is an embedding of containers,
  then so is \( \Rec_F(\alpha) : \Cart{\mu F}{G} \).
  \begin{proof}
    This is a direct application of the next result (\autoref{is-embedding-W-rec}) to the shape map \( \Rec_{F^{\prime}}(\alpha)_{\Sh} : \W(S,P) \to T \).
  \end{proof}
\end{lemma}

Recall that non-dependent recursion on \( \W(S, P) \) into a type \( A \) is given by
\begin{align*}
  \WRec &: \big(\big( { \textstyle \sum_{s : S} (P(s) \to A) } \big) \to A \big) \to (\W(S, P) \to A) \\
  \WRec&_h(\Sup(s, f)) \DefEq h(s, \WRec(h) \circ f)
\end{align*}
This map preserves embeddings:
\begin{lemma}\label{is-embedding-W-rec}
  Let \( S : \Type \) and \( P : S \to \Type \).
  For all \( A : \Type \),
  if \( { h : ( \sum_{s : S} (P(s) \to A) ) \to A } \) is an embedding,
  then so is \( \WRec_h : \W(S, P) \to A \).
  \begin{proof}
    It suffices to show that fibers over the image of \( \WRec_h \) are propositions,
    i.e. that \( \prod_{w : \W(S, P)} \Op{isProp}(\Fiber_{\WRec_h}(\WRec_h(w)))  \).
    We do so by \( \W \)-induction.
    Let \( s : S \), \( f : P(s) \to \W(S, P) \),
    and consider the type of fibers over \( \Sup(s, f) \):
    \begin{align*}
      {} &\mathrel{\hphantom{\simeq}}
        \Fiber_{\WRec_h}(\WRec_h(\Sup(s, f)))
      \intertext{
        By the computation rule for \( \W \)-recursion, it is equivalent to
      }
        &\simeq
        \sum_{w : \W(S, P)} h(x) = h(s, \WRec_h \circ f)
      \intertext{
        where \( x \) is a term involving \( w \), to be expanded later.
        Since \( h \) is an embedding, we can cancel it from the path type:
      }
        &\simeq
        \sum_{w : \W(S, P)} x = (s, \WRec_h \circ f)
      \intertext{
        Unfolding \( w : \W(S, P) \) via \( \WIn \) and expanding \( x \),
        we obtain
      }
        &\simeq
        \adjustlimits\sum_{s' : S} \sum_{f' : P(s') \to \W(S, P)}
          (s', \WRec_h \circ f') = (s, \WRec_h \circ f)
      \intertext{
        Breaking up the path of pairs into a pair of paths, we rearrange:
      }
        &\simeq
        \adjustlimits\sum_{(s\mathrlap{'} , q) : \Singl(s)} \sum_{f' : P(s') \to \W(S, P)}
          \WRec_h \circ f' =_{q} \WRec_h \circ f
      \intertext{
        Contracting \( \Singl(s) \) and applying function extensionality to the right,
        we are left with
      }
        &\simeq
        \sum_{f' : P(s) \to \W(S, P)}
          \prod_{p : P(s)}
          \WRec_h(f'(p)) = \WRec_h(f'(p))
      \intertext{
        Distributing \( \Sigma \) over \( \Pi \),
        we get
      }
        &\simeq
          \prod_{p : P(s)}
            \sum_{w : \W(S, P)}
            \WRec_h(w) = \WRec_h(f(p))
    \end{align*}
    For any \( p : P(s) \), the codomain of this type is
    \( \Fiber_{\WRec_h}(\WRec_h(f(p)) \).
    But since \( f(p) : \W(S, P) \) is structurally smaller than \( \Sup(s, f) : \W(S, P) \),
    this type is a proposition by the induction hypothesis.
    Hence, all fibers over the image of \( \WRec_h \) are propositions,
    and \( \WRec_h \) is an embedding.
  \end{proof}
\end{lemma}

This tells us that \( \MuRule_F \) embeds \( \mu F' \) as a subcontainer inside of \( \Der(\mu F) \):
\begin{lemma}\label{is-embedding-mu-rule}
  For all \( F : \Cont_{I + 1} \), the shape map \( (\MuRule_F)_{\Sh} \) is an embedding.
  \begin{proof}
    By the indexed analogue of \autoref{is-embedding-chain-rule},
    the shape map of the chain rule is an embedding.
    This lifts to \( \alpha \), and from there to \( \MuRule_F \JudgeEq \Rec_F(\alpha) \) by \autoref{is-equiv-from-mu-rec}.
  \end{proof}
\end{lemma}

From this, we can conclude that a strong chain rule alone is enough to prove a strong \( \mu \)-rule:
\begin{proposition}\label{strong-chain-rule-to-strong-mu-rule}
  Let \( F : \Cont_{I + 1} \).
  If  \( \Chain_{F,{\mu F}} \) is an equivalence, then so is \( \MuRule_F \).
  \begin{proof}
    Since \( \MuRule_F \) is always an embedding (\autoref{is-embedding-mu-rule}),
    it suffices to show that its shape map is a surjection.
    In fact, it is a split surjection: it has a section, hence all of its fibers are inhabited, not just merely inhabited.
    Assume \( \Chain_{F,{\mu F}} \) to be an equivalence.
    By \autoref{strong-binary-chain-rule-iff-is-equiv-sigma-isolate}, this is equivalent to isolated pairs
    \( (p_1, \bar{w}) \)
    having isolated components \( p_1 : P_1(s) \) and \( \bar{w} : \bar{\W}(f{p_1}) \),
    for all \( s : S \) and \( f : P_1(s) \to \W_{\!S}(P_1) \).
    This property is exactly what is needed to define a section to the shape map.
  \end{proof}
\end{proposition}

Thus, whether the \( \mu \)-rule is strong depends only on the chain-rule:
\begin{theorem}\label{strong-mu-rule-iff-strong-chain-rule}
  For any container \( F : \Cont_{I + 1} \), the following are equivalent:
  \begin{enumerate}
    \item \( \MuRule_F \) is an equivalence.
    \item \( \Chain_{F,{\mu F}} \) is an equivalence.
  \end{enumerate}
  \begin{proof}
    One direction is \autoref{strong-chain-rule-from-strong-mu-rule},
    the other is \autoref{strong-chain-rule-to-strong-mu-rule}.
  \end{proof}
\end{theorem}

With this at hand, we can give a proof that the \( \mu \)-rule is strong for discrete containers
that factors solely through the properties of the chain rule.
First, note that \( \bar{\W} \) preserves discreteness:
\begin{lemma}
  If \( B, C : A \to \Type \) are families of discrete types,
  then \( \bar{\W}_{A,B,C} \) is a discrete family.
  \begin{proof}
    By induction on \( \W(A, B) \) and unfolding via \( \WPathIn \).
  \end{proof}
\end{lemma}
This implies that discrete containers are closed under \( \mu \):
\begin{lemma}\label{mu-discrete}
  If \( F : \Cont_{I + 1} \) is a discrete container, then so is \( \mu F \).
\end{lemma}
Hence, we obtain a strong \( \mu \)-rule for discrete containers:
\begin{proposition}[note={\cite[{Proposition 8.1}]{AbbottEtAl2005DataDifferentiating}}]
  If \( F : \Cont_{I + 1} \) is discrete, then \( \MuRule_F \) is an equivalence.
  \begin{proof}
    By \autoref{strong-mu-rule-iff-strong-chain-rule}, it suffices to show that \( \Chain_{F,\mu F} \) is an equivalence.
    But \( \mu F \) is discrete (\autoref{mu-discrete}), and the chain-rule between discrete containers is strong (\autoref{discrete-strong-binary-chain-rule}).
  \end{proof}
\end{proposition}
