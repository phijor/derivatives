\section{Introduction}

A container \cite{AbbottEtAl2005ContainersConstructingstrictly} encodes the signature of an inductive data type:
it consists of a collection of shapes \( S \), each \( s : S \) representing a constructor,
and for each a collection of positions \( P(s) \), indexing arguments of the constructor.
Many operations on data types can be made precise as operations on containers,
including sums \( F \CPlus G \), products \( F \CTimes G \) and substitution \( \Subst{F}{G} \), allowing us to reason about them.

Another important operation on containers is that of a derivative.
It traces back to \citeauthor{Huet1997Zipper}'s \citetitle{Huet1997Zipper}~\cite{Huet1997Zipper},
a procedure for computing a type of contexts around a subtree in a tree-shaped data type.
In~\cite{McBride2001DerivativeRegularType}, \citeauthor{McBride2001DerivativeRegularType}
notices that for the class of \enquote{regular types}, one-hole contexts behave like a derivative of functions in calculus:
they satisfy similar rules for constants, sums and products, and their substitution follows a chain rule.
\Citeauthor{AbbottEtAl2003DerivativesContainers} extend this to a derivative operation on containers,
first in a categorical meta-language~\cite{AbbottEtAl2003DerivativesContainers},
then in a type-theoretic one~\cite{AbbottEtAl2005DataDifferentiating}.
They show that derivatives of containers satisfy a universal property with respect to a class of \enquote{cartesian}
morphisms \( F \multimap G \) of containers.
Namely, for any container \( G \) on which equality of positions is decidable,
cartesian morphisms \( F \multimap \Der{G} \) are in 1-to-1 correspondence with cartesian morphisms \( F \CTimes \Id \multimap G \).
Furthermore, the laws of derivatives are encoded as isomorphisms:
the chain rule, for example, becomes an isomorphism of containers
\( \Der{(\Subst{F}{G})} \cong \Subst{(\Der{F})}{G} \CTimes \Der{G} \).

In the meantime, other notions of containers have appeared,
whose shapes and positions have different kinds of structure:
quotient- \cite{AbbottEtAl2004ConstructingPolymorphicPrograms} and action containers~\cite{JoramVeltri2025DataTypesSymmetries}
express symmetries by having groups act on sets of positions,
symmetric containers internalize symmetries in a groupoid of shapes~\cite{Gylterud2011},
and categorified containers~\cite{AltenkirchKaposi2021containermodeltype} describe directed relations of shapes as a category.

When working in Univalent Foundations, the most direct generalization of containers is the one from sets to arbitrary types
with potentially non-trivial higher path types:
an \emph{untruncated} container \( (\MkCont{S}{P}) \) consists of a \emph{type} of shapes \( S \), and a \emph{type} of positions \( P(s) \) for each shape \( s : S \).
Untruncated containers subsume many notions of containers that express symmetries of constructors by encoding them in the (higher) path types of shapes.
Much of the theory of set-truncated containers transfers directly, since it never assumed that types were sets in the first place.
Does the same apply to derivatives of containers?
At a glance this seems unlikely because, unlike other constructions on containers, traditional derivatives are special:
They are only well-behaved for \emph{discrete} containers, i.e. those whose positions are discrete.
By Hedberg's Theorem, positions of discrete containers must be sets, meaning that a generalization to a type of untruncated positions seems impossible.

In this paper, we show how to define derivatives of untruncated containers in spite of this apparent obstacle.
We tackle the problem in to steps.
At first, an exercise in reverse mathematics:
In our definition of a derivative, what are the minimal assumptions on decidability that we can make which do not force positions to be sets?
Having found a potential generalized derivative, we ask whether it behaves correctly:
Does it satisfy a universal property like discrete containers do?
Do laws of derivatives hold? Is there a chain rule?

To this end, in \autoref{isolated-points} we recall the notion of \emph{isolatedness} of a point in a type.
This is a local notion of discreteness, considered in type theory, for example, by \citeauthor{KrausEtAl2013GeneralizationsHedberg’sTheorem}~\cite{KrausEtAl2013GeneralizationsHedberg’sTheorem}.
To each type \( A \), we associate its \emph{set} of isolated points \( \Isolated{A} \)\kern-0.20em,
and show how it distributes over various type formers.
We make three observations:
First, isolated points distributing over \( \Sigma \)-types is a constructive taboo which would imply discreteness of arbitrary types.
Second, removal of points from a type, \( A \setminus a \), is well-behaved for even for arbitrary \( A : \Type \),
as long as \( a \) is an isolated point.
Third, functions out of types pointed by an isolated point are characterized by an induction-like principle.

In \autoref{derivatives}, we use this to define a derivative that only ranges over isolated positions;
this allows us to prove the following universal property
by application of simple lemmata for isolated points:
On the (wild) category \( \ContCart \) of containers and cartesian morphisms,
\( \Der \) is an endofunctor,
and it is right-adjoint to taking products with the identity container, \( \Maybe{\Blank} \).
As a consequence, we can solve a problem left open in \cite[14]{AbbottEtAl2005DataDifferentiating}:
the wild adjunction restricts to an ordinary adjunction on the 1-category of set-truncated containers.
In particular, this proves that \emph{every} set-truncated container has a well-behaved derivative, not just discrete ones.
Our exercise pays off: by generalizing to arbitrary types, we learn something about sets.
Verifying that this generalized derivative satisfies the basic laws for constants, sums and products is straightforward;
we essentially repurpose the proofs for the special case of discrete containers,
but distribute isolated points over type formers whenever necessary.

The goal of \autoref{chain-rule} is to derive a chain rule.
While it is possible to give a \emph{lax} chain rule, i.e. a cartesian morphism
from
\( \Subst{(\Der{F})}{G} \CTimes \Der{G} \)
to
\( \Der{(\Subst{F}{G})} \),
we prove that it cannot be inverted in general:
A strong chain rule for arbitrary containers is inconsistent in the presence of non-set types.
Even when restricted to set-truncated containers, this implies a constructive taboo.
We can, however, show constructively that it is an embedding of containers.

In \autoref{fixed-points}, we apply the previous results to show that derivatives of smallest fixed points can be characterized entirely by the chain rule.
We ensure that every container \( F \) has a smallest fixed point \( \mu F \) in the wild category of containers:
We prove that every (wild) substitution functor \( \Subst{F}{\Blank} : \ContCart \to \ContCart \) admits an initial algebra.
This is different from the usual approach in which \( \mu F \) is defined in terms of an associated container functor \( \Ext{F} \) of sets \cite{AbbottEtAl2005ContainersConstructingstrictly,DamatoEtAl2025FormalisingInductiveCoinductive}.
We do so to avoid coherence problems in the translation from container functors back to containers:
usually, properties of container functors are pulled back along \( \Ext{\Blank} \), a full and faithful functor of 1-categories.
In our setting, this is a functor of wild categories, and proving that it preserves the necessary structure is not straightforward.
Lastly, we construct a lax \( \mu \)-rule as an embedding of a fixed point \( \mu F' \) into \( \Der(\mu F) \), in which \( F' \) is derived naturally from \( F \).
This embedding characterizes \( \Der(\mu F) \) entirely in terms of the chain rule:
it is an equivalence if and only if the chain rule for \( F \) and \( \mu F \) is an equivalence.
In other words, the \( \mu \)-rule is strong exactly when the associated chain rule is.

We develop our results as an Agda library,
implemented in its \href{https://agda.readthedocs.io/en/v2.8.0/language/cubical.html}{cubical} mode,
building on top of the \texttt{agda/cubical} library~\cite{AgdaCommunity2025CubicalAgdaLibrary}.
The library, together with a mapping of all results of this paper to their definitions in code,
is available at
\begin{center}
  \url{https://codeberg.org/phijor/derivatives}
\end{center}

In this paper, we work in Homotopy Type Theory, an extension of intensional Martin--Löf type theory.
Our notation and conventions mostly follow that of the HoTT Book~\cite{UnivalentFoundationsProgram2013HomotopyTypeTheory},
some of which we are going to recall now:

\paragraph{Types and terms.}
All of our types live in a single univalent universe, \( \Type \), unless stated otherwise.
We assume the existence of a unit type \( 1 \), empty type \( 0 \), natural numbers \( \mathbb{N} \), products \( A \times B \), coproducts \( A + B \), and function types \( A \to B \),
as well as their dependent analogues:
For \( A : \Type \) and a family \( B : A \to \Type \),
we denote dependent function types by \( \Pi_{A} B \) or \( \prod_{a : A} B(a) \),
and dependent sum types by \( \Sigma_{A} B \) or \( \sum_{a : A} B(A) \).
We do not assume the existence of higher inductive types apart from a propositional truncation \( \PropTrunc{\Blank} \),
or to illustrate examples.
A type \( A \) is merely inhabited if \( \PropTrunc{A} \) is inhabited.
For all \( n : \mathbb{N} \), we write \( \Fin{n} : \Type \) for the standard finite type of \( n \) elements,
i.e. \( \Fin{0} \DefEq 0 \) and \( \Fin{1+n} \DefEq 1 + \Fin{n} \).

Function application is written \( f(a, b) \).
We move arguments into subscripts, \( f_a(b) \), or even drop them, \( f(b) \), if they can be inferred from context without ambiguity.
The unit type is inhabited by \( \bullet : 1 \),
the coproduct has constructors \( \Inl : A \to A + B \) and \( \Inr : B \to A + B \).
Projections out of \( \times \) and \( \Sigma \) are denoted by \( \Op{fst} \) and \( \Op{snd} \).
We write \( \Sigma(f, g) : \Sigma_A B \to \Sigma_{A'} B' \) for the map that applies
\( f : A \to A' \) and \( g : \prod_{a : A} B(a) \to B'(f(a)) \) to the components of a \( \Sigma \)-type.

\paragraph{Equality.}
We denote by \( x \DefEq y \) a defining equality that binds a new name \( x \) to a term \( y \).
Defining equalities hold judgmentally, written \( x \JudgeEq y \), as do the usual \( \eta \)- and \( \beta \)-laws for \( \Sigma \)- and \( \Pi \)-types.
We use the same notation for \enquote{pattern matching} in proofs by induction on an inductive type.
For example, we split a proof by induction on \( x : A + B \) into cases \( x \JudgeEq \Inl(a) \) and \( x \JudgeEq \Inr(b) \).

The identity type in a type \( A \) is written \( x =_A y \), with the subscript dropped unless ambiguous.
For \( p : x = y \), we write \( p_* : B(x) \to B(y) \) for transport along \( p \) in a family \( B : A \to \Type \).
We write \( u =_p v \) for the type of dependent paths over \( p \) in \( B \) between points \( u : B(x) \) and \( v : B(y) \).

A type \( A \) is said to be contractible if \( \Op{isContr}(A) \DefEq \sum_{a : A} \prod_{b : A} a = b \) is inhabited.
It is a proposition if \( \Op{isProp}(A) \DefEq \prod_{a, b : A} a = b \) is inhabited.
We say that a type is \( n \)-truncated if it is contractible (\( n = -2 \)), a proposition (\( n = -1 \))
or its path types are \( (n-1) \)-truncated (\( n \geq 0 \)).
To avoid confusion, we name the truncation level for low \( n \):
0-truncated types are called sets, and 1-truncated types are groupoids.
If \( P : A \to \Type \) is a family of propositions, \( \Sigma_A P \) defines a subtype of \( A \).
We implicitly coerce terms \( a : \Sigma_A P \) to type \( A \) and write, for example,
\( f(a) : B \) instead of \( f(\Op{fst}(a)) \) when applying a function \( f : A \to B \).

\paragraph{Equivalences.}
A function \( f : A \to B \) is an equivalence if for all \( y : B \) the type of fibers \( \Fiber_f(y) \DefEq \sum_{x : A} f(x) = y \) is contractible.
Being an equivalence is a proposition, and we denote the induced subtype of functions by \( A \simeq B \).

We employ various techniques to show that a given map \( f : A \to B \) is an equivalence.
In simple cases it suffices to give some \( g : B \to A \) and show that \( g \) and \( f \) are mutually inverse,
i.e.\@ that \( f \circ g = \Op{id}_B \) and \( g \circ f = \Op{id}_A \).
Whenever possible, we decompose \( f \) into intermediate steps,
after which we appeal to the 3-for-2 property: In any commutative triangle
\[
  \begin{tikzcd}[column sep=small]
      & B & \\
    A &   & C
    \ar[from=2-1,to=1-2, "g"]
    \ar[from=1-2,to=2-3, "h"]
    \ar[from=2-1,to=2-3, "f"']
  \end{tikzcd}
\]
if any two maps are equivalences, then so is the third.
From this one can derive a number of techniques that minimize the tears shed over such proofs,
best illustrated in~\cite{Jong2025FormalizingEquivalencesTears}.
Similarly, \( f \) is an equivalence if and only if it is both an embedding and a surjection:
it is a surjection if all of its fibers are merely inhabited, and an embedding if one of the following equivalent properties holds:
\begin{itemize}
  \item \( \Fiber_f(y) \) is a proposition for all \( y : B \),
  \item \( \Fiber_f(f(x)) \) is a proposition for all \( x : A \), or
  \item \( \Op{cong}_{x,y} : x = y \to f(x) = f(y) \) is an equivalence
\end{itemize}

\paragraph{Wild categories.}
A 1-category \( \mathcal{C} \) consists of a type of objects \( \mathcal{C}_0 \) and a \emph{set} of morphisms
\( \mathcal{C}_1(x, y) \) for all \( x, y : \mathcal{C}_0 \),
together with a composition operation \( \Blank \circ \Blank \) and identity morphisms \( \Op{id} \)
satisfying the standard equalities.
A \emph{wild} category~\cite{CapriottiKraus2017UnivalentHigherCategories} consists of the same data,
except that the assumption that \( \mathcal{C}_1 \) is a family of sets is dropped.
We understand a wild category as the first approximation of an \( \infty \)-category ---
a useful tool in the absence of a fully coherent notion of higher category internal to Homotopy Type Theory:
Unlike in a 1-category, where commutativity of any diagram is a proposition,
equalities of morphisms in a wild category are \emph{data},
and we speak of them as \emph{fillers}.
When porting 1-categorical concepts to wild categories,
it is our obligation to ensure that these fillers compose coherently.
